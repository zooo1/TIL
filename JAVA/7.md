# 상속

> 부모가 가진 것을 자식에게 물려주는 것
>
> is a, kind of 관계라고 한다.





### Car를 상속받은 Bus를 class로 표현하는 방법

```java
public class Car{
  
}

public class Bus extends Car{
  
}
```

* 자바는 클래스 이름 뒤에 extends 키워드를 적고 부모 클래스 이름을 적는다.
* 부모가 가지고 있는 것을 자식이 사용할 수 있다.



### 부모클래스에 메소드 추가하기

#### Car에 run() 메소드 추가

```java
public class Car{
  public void run(){
    System.out.println("달리다.");
  }
}
```

#### Car를 상속받은 Bus 사용

```java
public class BusExam{
  public static void main(String[] args){
    Bus bus = new Bus();
    bus.run(); 
  }
}
```

#### Bus에 메소드 추가

```java
public class Bus extends Car{
  public void ppangppang(){
    System.out.println("빵빵");
  }
}
```

* Bus는 Car에서 물려받은 run 메소드와 ppangppang 메소드를 사용할 수 있다.
* 부모가 가지고 있는 메소드외에 추가로 메소드를 선언하는 것: **확장**하였다고 표현





# 접근제한자

> 클래스 내에서 멤버의 접근을 제한하는 역할



### 종류

* public

  어떤 클래스든 접근할 수 있다.

* protected

  자신, 패키지, 상속받은 자식 클래스(서로 다른 패키지)에서는 접근할 수 있다.

* private

  자신만 접근할 수 있다.

* default(접근제한자를 적지 않은 경우)

  자신과 같은 패키지에서만 접근할 수 있다.



### 범위

Public > protected > default > private



```java
public class AccessObj{
  private int i = 1;
  int k = 2;
  public int p = 3;
  protected int p2 = 4;
}
```

```java
public class AccessObjExam{
  public static void main(String args[]){
    AccessObj po = new AccessObj();
    System.out.println(po.i); // 컴파일 오류
    System.out.println(po.k);
    System.out.println(po.p);
    System.out.println(po.p2);
  }
}
```

* AccessObj와 AccessObjExam을 다른 패키지에서 사용

  * i : 컴파일 오류(자신만 접근 가능하기 때문)
  * k: 컴파일 오류(자신과 다른 패키지여서)
  * p: 가능 
  * p2: 컴파일 오류(상속받지 않아서)

* AccessObjExam을 AccessObj에서 상속받도록 수정한 후 사용해보기

  ```java
  public class AccessObjExam extends AccessObj{
    public static void main(String[] args){
      AccessObjExam obj = new AccessObjExam();
      System.out.println(obj.p);
      System.out.println(obj.p2);
      System.out.println(obj.k);// 컴파일 오류
      System.out.println(obj.i);// 컴파일 오류  
    }
  }
  ```





# 추상클래스

> 구체적이지 않은 클래스



### 정의

* class 앞에 abstract 키워드를 이용해서 정의한다.
* 미완성의 추상 메소드를 포함할 수 있다.
  * 추상메소드란 내용이 없는 메소드이다. 즉, 구현이 되지 않은 메소드
  * 추상메소드는 return type 앞에 abstract라는 키워드를 붙여야 한다.
* 추상 클래스는 인스턴스를 생성할 수 없다.

```java
public abstract class Bird{
  public abstract void sing();
  public void fly(){
    System.out.println("날다");
  }
}
```



### 추상 클래스를 상속받는 클래스 생성하기

* 추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 반드시 구현해야 한다.
* 추상 클래스를 상속받고, 추상 클래스가 갖고 잇는 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다. 

```java
public class Duck extends Bird{
  @Override
  public void sing(){
    System.out.println("꽥꽥");
  }
}
```



### 사용하기

```java
public class DuckExam{
  public static void main(String[] args){
    Duck duck = new Duck();
    duck.sing();
    duck.fly();
    
    // Bird b = new Bird(); 
    // Bird는 추상 클래스이므로 객체를 생성할 수 없다!
  }
}
```

