# 배열

## 배열의 기본 개념

### 배열이란

> 동일한 데이터형 변수의 집합
>
> int a[5]; // int형 변수 5개가 할당 됨

### 배열 선언 규칙

* 배열명 뒤의 대괄호`[]` 안에 **정수형첨자** 를 지정하면 첨자수 만큼 배열의 요소가 할당됨

### 배열의 특징

* 메모리 상의 연속적인 공간에 할당된다.

  > 논리적개념. 

* 배열명은 곧 그 배열의 시작주소상수이다. 

  > sizeof(배열명) => 배열의 전체크기

* 배열 요소는 첨자로 구분하며 `0` 부터 시작된다. 

  > 선언문에서의 첨자는 배열요소의 개수를
  >
  > 실행문에서의 첨자는 배열요소의 번호를 의미한다.

  

## 1차원 배열의 선언 및 초기화

### 1차원 숫자배열의 선언

```c
int ary[10]; // int 방 10개로 구성된 1차원 배열 선언
```

### 차원 및 차원 조절

* c 코드 내에서 사용되는 모든 상수나 변수는 차원이 부여되어있다.
* 상수나 변수의 차원은 차원 조절 연산자에 의해서 차원이 변결될 수 있다.
* Lvalue, Rvalue는 차원이 같아야 대입연산이 가능하다.(주소상수는 자동 형변환이 불가능하다.)



### 차원 조절 연산자

| 연산자 | 선언문    | 일반 실행문          | 비고                                  |
| ------ | --------- | -------------------- | ------------------------------------- |
| * []   | 차원 올림 | 차원 내림            | 중복 사용 가능 int ***p;              |
| &      | 사용 불가 | 차원 올림            | 중복 사용 불가능 int a; &&&a;         |
| (type) | 사용 불가 | 여러차원 올리고 내림 | 피연산자의 type, 차원을 고려하지 않음 |
| ->     | 사용 불가 | 차원 내림            | 중복 사용 불가능 (p+1) -> ->          |



### 메모

```c
int a[5] ={ 1,2,3,4,5}; 
// a의 주소가 100번지라고 가정하자.
printf("%p", a); // 00000064
printf("%u", a); // 100
printf("%u", sizeof(a)); // 16 
// a: 배열 전체의 크기!!(배열 이름으로서의 기능)
```

```c
int a[7.5]; // 불가능
int a['A']; // 65개의 방(문자의 데이터형: 정수)
```

```c
char str[10]; // str의 주소를 200번지라고 가정
unsigned int l1, l2;
str = "안뇽" // ERROR! 왜? str이라고 하는 것은 주소 상수를 의미한다. 따라서 문자열을 복사해주어야한다. 
strcpy(str, "안뇽"); // 문자열은 곧 그 문자열의 시작 주소 상수 -> "안뇽\0" 또한 주소를 가지고 있다.(700번지라고 가정) 
l1 = sizeof(str); // 10
l2 = strlen(str); // 4(한글은 한 글자당 2byte)
```

```c
int a =7;
int *p = &a;
a = 3; 
*p = 3; // p가 가리키는 곳에 3을 대입
// p: 1차원 *p: 0차원
```

```c
int ary[5];

ary = 1; // ary는 1차원, 1은 0차원이기 때문에 불가능
ary[2] = 1; // 가능
```

```c
int a =7;
int ***p;
p = (int***)&a;
printf("a의 주소 %u\n", &a);
printf("p가 가리키는 곳: "); 
printf("%u ", p); //a의 주소
p = (int***) a;
printf("%u ", p); // a의 값

```



### 1차원 배열의 초기화

* 배열 전체의 초기화는 선언문에서만 가능하다.

* 배열을 초기화 할 때는 초기화 시작과 끝 괄호로 중괄호를 이용하여 초기화할 데이터를 묶어서 표현한다.

  > 단, 1차원 char 배열을 문자열로 초기활 할 때에는 중괄호를 생략할 수 있다.

* 배열 요소의 개수보다 초기화 데이터가 부족하면 남는 요소는 0으로 채워진다.

* 배열 요소의 개수보다 초기화 데이터가 많으면 컴파일 에러가 발생한다.

* 배열 선언 시 첨자는 생략할 수 없으나 초기화 데이터가 잇는 경우에 한하여 첨자를 생략할 수 있다.

  > ```c
  > int a[] ; // ERROR
  > int a[] = {1,2,3}; // 가능 
  > char str = "hi";
  > ```

* 문자열을 char 배열에 저장할 때는 배열이 첨자 크기를 문자열의 길이 + 1(NULL) 만큼으로 정한다. 



### 메모

```c
int a[4];
a = {1,2,3,4,5}; // 실행문에서 초기화 할 수 없다!!

char c[10] = "kiwi";
char c[10] = {'k', 'i', 'w', 'i'};

char s[10];
strcpy(s, "kiwi");

int a[4] = {1,3}; // 1 3 0 0
int a[4] = {0,};  // 0 0 0 0
int a[4] = {1};   // 1 0 0 0
int a[4] = {1,3,5,7,9}; //ERROR

char str[4] = "apple" // compile error
```

```c
char str[3];
str[0] = 'h';
str[0] = 'i';
str[0] = '\0';
// 실행문에서는 반드시 맨 뒤에 '\0'을 붙여줘야한다.
```



## 배열에 file내의 데이터 저장하기

#### fopen()함수 사용

```c
int main(){
  FILE *fp;
  int n;
  fp = fopen("C://경로", "r"); // r:읽기모드
  // 데이터 읽기
  fscanf(fp, "%d", &n);
  fclose(fp);
}
```



## 2차원 배열의 선언 및 초기화

### 2차원 배열의 선언

```c
int ary[3][4];
```



### 2차원 배열의 초기화

* 2차원 숫자 배열을 초기화 할 때는 초기화 시작과 끝 괄호 외에도 각 행의 초기화 시작과 끝 괄호를 넣어준다.

  ```c
  int ary[3][4] = {{1,1,1,1,}, {2,2,2,2,}, {3,3,3,3}};
  int ary[3][4] = {1,1,1,1,2,2,2,2,3,3,3,3};
  
  int ary[3][4] = {{1,1}, {2,2,2}, {3,3,3,3}};
  int ary[3][4] = {1,1,0,0,2,2,2,0,3,3,3,3};
  
  int ary[3][4] = {1,1,2,2,3,3,3,3};
  int ary[3][4] = {1,1,2,2,3,3,3,3,0,0,0,0};
  
  ```

*  2차원 문자 배열을 초기화 할 때는 문자열의 개수만큰 행 첨자를 지정하고 열 첨자는 초기화 문자열들 중 가장 긴 문자열의 길이에 NULL 문자를 위하여 +1 한 크기로 정한다. 2차원 문자 배열 초기화 시에는 배열 초기화 시작, 끝 괄호를 생략할 수 없다.

  ```c
  char str[3][7] ={"kiwi", "apple", "banana"};s
  ```



### 메모

* 배열의 구성요소: 자신 보다 작은 메모리로 구성되어 있는 것

  > ```c
  > int a[3][4];
  > ```
  >
  > 구성요소 
  >
  > 1. int 방 12개
  > 2. int 방 4개(`int[4]`)짜리 배열 3개
  > 3. ~~`int[3][4]` 배열 1개~~

* 배열은 곧 그 배열의 시작주소이다.(type, 차원)

  > ```c
  > int ary[3][4];
  > sub(ary);
  > void sub(int**p){} // nope!!!!!!
  > void sub(int (*p)[4]){}
  > // 방 4개짜리 배열의 주소라는 뜻
  > ```

* 차원 관련 규칙

  > 1. n차원의 방의 시작주소는 n+1차원이다.
  > 2. n차원 배열의 시작주소는 그 배열의 가장 큰 구성요소의 한 차원 높은 주소이다.

* `int ary[3][4] `

  > 다음 표현의 의미는?(시작 주소를 100번지라고 가정하자.)
  >
  > | 배열 표현    | 차원              | 의미                      |
  > | ------------ | ----------------- | ------------------------- |
  > | `ary`        | 2차원(int (*)[4]) | ary 배열의 시작주소       |
  > | `ary[0]`     | 1차원(int *)      | ary의 0행 배열 주소       |
  > | `ary[0][0]`  | 0차원(int)        | ary 배열의 0 행 0 열 방   |
  > | `&ary[0][0]` | 1차원(int *)      | ary 배열 0 행 0 열의 주소 |
  >
  > 주소가 같더라도 차원이 다를 수 있다.

* parameter 자리에서 선언된 배열은 실제로 배열로 할당되지 않고 그렇게 생긴 배열을 가리키는 포인터 변수로 할당된다. (주소를 배열로 받을리는 없으므로)

* 가능할까?

  > ```c
  > char str[3][6] ={"year", "month", "day"};
  > 
  > str[1][8] = '$';
  > // 1. compile error
  > // 2. runtime error
  > // 3. ok?
  > // 답: 3 이유: 메모리가 연결되어있기 때문. 심지어 예약된 메모리이다.
  > 
  > str[2][8] = '@';
  > // runtime error!!
  > // 미예약 영역이기 때문
  > ```



## 배열과 증감 연산자

```c
ary[i++] // ary[i]의 값을 사용 후 i의 값을 1 증가
ary[++i] // i의 값을 1 증가시킨 후 ary[i]의 값 사용 
--ary[i] // ary[i]의 값을 -1 감소 시킨 후 ary[i]의 값을 사용
ary[i]-- // ary[i]의 값을 사용 후 ary[i]를 1 감소
```



## 배열선언 및 초기화 시의 주의점

### 첨자 생략 규칙

1. 배열 선언 시 첨자를 생략하기 위해서는 꼭 선언문에서 배열을 초기화 해야한다.
2. 배열의 첨자 중 가장 큰 첨자 1개만 생략이 가능하다.(면> 행> 열)